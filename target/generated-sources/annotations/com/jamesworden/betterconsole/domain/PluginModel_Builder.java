// Autogenerated code. Do not modify.
package com.jamesworden.betterconsole.domain;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import java.util.EnumSet;
import java.util.Objects;
import java.util.function.UnaryOperator;
import javax.annotation.Generated;

/**
 * Auto-generated superclass of {@link PluginModel.Builder}, derived from the API of {@link
 * PluginModel}.
 */
@Generated("org.inferred.freebuilder.processor.Processor")
abstract class PluginModel_Builder {

  /**
   * Creates a new builder using {@code value} as a template.
   *
   * <p>If {@code value} is a partial, the builder will return more partials.
   */
  public static PluginModel.Builder from(PluginModel value) {
    if (value instanceof Rebuildable) {
      return ((Rebuildable) value).toBuilder();
    } else {
      return new PluginModel.Builder().mergeFrom(value);
    }
  }

  private enum Property {
    NAME("name"),
    DESCRIPTION("description"),
    VERSION("version"),
    IGNORED("ignored"),
    ENABLED("enabled"),
    ;

    private final String name;

    private Property(String name) {
      this.name = name;
    }

    @Override
    public String toString() {
      return name;
    }
  }

  private String name;
  private String description;
  private String version;
  private boolean ignored;
  private boolean enabled;
  private final EnumSet<Property> _unsetProperties = EnumSet.allOf(Property.class);

  /**
   * Sets the value to be returned by {@link PluginModel#getName()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code name} is null
   */
  public PluginModel.Builder setName(String name) {
    this.name = Objects.requireNonNull(name);
    _unsetProperties.remove(Property.NAME);
    return (PluginModel.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link PluginModel#getName()} by applying {@code mapper}
   * to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public PluginModel.Builder mapName(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return setName(mapper.apply(getName()));
  }

  /**
   * Returns the value that will be returned by {@link PluginModel#getName()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getName() {
    Preconditions.checkState(!_unsetProperties.contains(Property.NAME), "name not set");
    return name;
  }

  /**
   * Sets the value to be returned by {@link PluginModel#getDescription()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code description} is null
   */
  public PluginModel.Builder setDescription(String description) {
    this.description = Objects.requireNonNull(description);
    _unsetProperties.remove(Property.DESCRIPTION);
    return (PluginModel.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link PluginModel#getDescription()} by applying {@code
   * mapper} to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public PluginModel.Builder mapDescription(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return setDescription(mapper.apply(getDescription()));
  }

  /**
   * Returns the value that will be returned by {@link PluginModel#getDescription()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getDescription() {
    Preconditions.checkState(
        !_unsetProperties.contains(Property.DESCRIPTION), "description not set");
    return description;
  }

  /**
   * Sets the value to be returned by {@link PluginModel#getVersion()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code version} is null
   */
  public PluginModel.Builder setVersion(String version) {
    this.version = Objects.requireNonNull(version);
    _unsetProperties.remove(Property.VERSION);
    return (PluginModel.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link PluginModel#getVersion()} by applying {@code
   * mapper} to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public PluginModel.Builder mapVersion(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return setVersion(mapper.apply(getVersion()));
  }

  /**
   * Returns the value that will be returned by {@link PluginModel#getVersion()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getVersion() {
    Preconditions.checkState(!_unsetProperties.contains(Property.VERSION), "version not set");
    return version;
  }

  /**
   * Sets the value to be returned by {@link PluginModel#isIgnored()}.
   *
   * @return this {@code Builder} object
   */
  public PluginModel.Builder setIgnored(boolean ignored) {
    this.ignored = ignored;
    _unsetProperties.remove(Property.IGNORED);
    return (PluginModel.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link PluginModel#isIgnored()} by applying {@code mapper}
   * to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public PluginModel.Builder mapIgnored(UnaryOperator<Boolean> mapper) {
    Objects.requireNonNull(mapper);
    return setIgnored(mapper.apply(isIgnored()));
  }

  /**
   * Returns the value that will be returned by {@link PluginModel#isIgnored()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public boolean isIgnored() {
    Preconditions.checkState(!_unsetProperties.contains(Property.IGNORED), "ignored not set");
    return ignored;
  }

  /**
   * Sets the value to be returned by {@link PluginModel#isEnabled()}.
   *
   * @return this {@code Builder} object
   */
  public PluginModel.Builder setEnabled(boolean enabled) {
    this.enabled = enabled;
    _unsetProperties.remove(Property.ENABLED);
    return (PluginModel.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link PluginModel#isEnabled()} by applying {@code mapper}
   * to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public PluginModel.Builder mapEnabled(UnaryOperator<Boolean> mapper) {
    Objects.requireNonNull(mapper);
    return setEnabled(mapper.apply(isEnabled()));
  }

  /**
   * Returns the value that will be returned by {@link PluginModel#isEnabled()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public boolean isEnabled() {
    Preconditions.checkState(!_unsetProperties.contains(Property.ENABLED), "enabled not set");
    return enabled;
  }

  /**
   * Copies values from {@code value}.
   *
   * @return this {@code Builder} object
   */
  public PluginModel.Builder mergeFrom(PluginModel value) {
    PluginModel_Builder defaults = new PluginModel.Builder();
    if (defaults._unsetProperties.contains(Property.NAME)
        || !Objects.equals(value.getName(), defaults.getName())) {
      setName(value.getName());
    }
    if (defaults._unsetProperties.contains(Property.DESCRIPTION)
        || !Objects.equals(value.getDescription(), defaults.getDescription())) {
      setDescription(value.getDescription());
    }
    if (defaults._unsetProperties.contains(Property.VERSION)
        || !Objects.equals(value.getVersion(), defaults.getVersion())) {
      setVersion(value.getVersion());
    }
    if (defaults._unsetProperties.contains(Property.IGNORED)
        || value.isIgnored() != defaults.isIgnored()) {
      setIgnored(value.isIgnored());
    }
    if (defaults._unsetProperties.contains(Property.ENABLED)
        || value.isEnabled() != defaults.isEnabled()) {
      setEnabled(value.isEnabled());
    }
    return (PluginModel.Builder) this;
  }

  /**
   * Copies values from {@code template}, skipping unset properties.
   *
   * @return this {@code Builder} object
   */
  public PluginModel.Builder mergeFrom(PluginModel.Builder template) {
    // Upcast to access private fields; otherwise, oddly, we get an access violation.
    PluginModel_Builder base = template;
    PluginModel_Builder defaults = new PluginModel.Builder();
    if (!base._unsetProperties.contains(Property.NAME)
        && (defaults._unsetProperties.contains(Property.NAME)
            || !Objects.equals(template.getName(), defaults.getName()))) {
      setName(template.getName());
    }
    if (!base._unsetProperties.contains(Property.DESCRIPTION)
        && (defaults._unsetProperties.contains(Property.DESCRIPTION)
            || !Objects.equals(template.getDescription(), defaults.getDescription()))) {
      setDescription(template.getDescription());
    }
    if (!base._unsetProperties.contains(Property.VERSION)
        && (defaults._unsetProperties.contains(Property.VERSION)
            || !Objects.equals(template.getVersion(), defaults.getVersion()))) {
      setVersion(template.getVersion());
    }
    if (!base._unsetProperties.contains(Property.IGNORED)
        && (defaults._unsetProperties.contains(Property.IGNORED)
            || template.isIgnored() != defaults.isIgnored())) {
      setIgnored(template.isIgnored());
    }
    if (!base._unsetProperties.contains(Property.ENABLED)
        && (defaults._unsetProperties.contains(Property.ENABLED)
            || template.isEnabled() != defaults.isEnabled())) {
      setEnabled(template.isEnabled());
    }
    return (PluginModel.Builder) this;
  }

  /**
   * Resets the state of this builder.
   *
   * @return this {@code Builder} object
   */
  public PluginModel.Builder clear() {
    PluginModel_Builder defaults = new PluginModel.Builder();
    name = defaults.name;
    description = defaults.description;
    version = defaults.version;
    ignored = defaults.ignored;
    enabled = defaults.enabled;
    _unsetProperties.clear();
    _unsetProperties.addAll(defaults._unsetProperties);
    return (PluginModel.Builder) this;
  }

  /**
   * Returns a newly-created {@link PluginModel} based on the contents of this {@code Builder}.
   *
   * @throws IllegalStateException if any field has not been set
   */
  public PluginModel build() {
    Preconditions.checkState(_unsetProperties.isEmpty(), "Not set: %s", _unsetProperties);
    return new Value(this);
  }

  /**
   * Returns a newly-created partial {@link PluginModel} for use in unit tests. State checking will
   * not be performed. Unset properties will throw an {@link UnsupportedOperationException} when
   * accessed via the partial object.
   *
   * <p>The builder returned by {@link PluginModel.Builder#from(PluginModel)} will propagate the
   * partial status of its input, overriding {@link PluginModel.Builder#build() build()} to return
   * another partial. This allows for robust tests of modify-rebuild code.
   *
   * <p>Partials should only ever be used in tests. They permit writing robust test cases that won't
   * fail if this type gains more application-level constraints (e.g. new required fields) in
   * future. If you require partially complete values in production code, consider using a Builder.
   */
  @VisibleForTesting()
  public PluginModel buildPartial() {
    return new Partial(this);
  }

  private abstract static class Rebuildable implements PluginModel {
    public abstract Builder toBuilder();
  }

  private static final class Value extends Rebuildable {
    private final String name;
    private final String description;
    private final String version;
    private final boolean ignored;
    private final boolean enabled;

    private Value(PluginModel_Builder builder) {
      this.name = builder.name;
      this.description = builder.description;
      this.version = builder.version;
      this.ignored = builder.ignored;
      this.enabled = builder.enabled;
    }

    @Override
    public String getName() {
      return name;
    }

    @Override
    public String getDescription() {
      return description;
    }

    @Override
    public String getVersion() {
      return version;
    }

    @Override
    public boolean isIgnored() {
      return ignored;
    }

    @Override
    public boolean isEnabled() {
      return enabled;
    }

    @Override
    public Builder toBuilder() {
      PluginModel_Builder builder = new Builder();
      builder.name = name;
      builder.description = description;
      builder.version = version;
      builder.ignored = ignored;
      builder.enabled = enabled;
      builder._unsetProperties.clear();
      return (Builder) builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Value)) {
        return false;
      }
      Value other = (Value) obj;
      return Objects.equals(name, other.name)
          && Objects.equals(description, other.description)
          && Objects.equals(version, other.version)
          && ignored == other.ignored
          && enabled == other.enabled;
    }

    @Override
    public int hashCode() {
      return Objects.hash(name, description, version, ignored, enabled);
    }

    @Override
    public String toString() {
      return "PluginModel{name="
          + name
          + ", description="
          + description
          + ", version="
          + version
          + ", ignored="
          + ignored
          + ", enabled="
          + enabled
          + "}";
    }
  }

  private static final class Partial extends Rebuildable {
    private final String name;
    private final String description;
    private final String version;
    private final boolean ignored;
    private final boolean enabled;
    private final EnumSet<Property> _unsetProperties;

    Partial(PluginModel_Builder builder) {
      this.name = builder.name;
      this.description = builder.description;
      this.version = builder.version;
      this.ignored = builder.ignored;
      this.enabled = builder.enabled;
      this._unsetProperties = builder._unsetProperties.clone();
    }

    @Override
    public String getName() {
      if (_unsetProperties.contains(Property.NAME)) {
        throw new UnsupportedOperationException("name not set");
      }
      return name;
    }

    @Override
    public String getDescription() {
      if (_unsetProperties.contains(Property.DESCRIPTION)) {
        throw new UnsupportedOperationException("description not set");
      }
      return description;
    }

    @Override
    public String getVersion() {
      if (_unsetProperties.contains(Property.VERSION)) {
        throw new UnsupportedOperationException("version not set");
      }
      return version;
    }

    @Override
    public boolean isIgnored() {
      if (_unsetProperties.contains(Property.IGNORED)) {
        throw new UnsupportedOperationException("ignored not set");
      }
      return ignored;
    }

    @Override
    public boolean isEnabled() {
      if (_unsetProperties.contains(Property.ENABLED)) {
        throw new UnsupportedOperationException("enabled not set");
      }
      return enabled;
    }

    private static class PartialBuilder extends Builder {
      @Override
      public PluginModel build() {
        return buildPartial();
      }
    }

    @Override
    public Builder toBuilder() {
      PluginModel_Builder builder = new PartialBuilder();
      builder.name = name;
      builder.description = description;
      builder.version = version;
      builder.ignored = ignored;
      builder.enabled = enabled;
      builder._unsetProperties.clear();
      builder._unsetProperties.addAll(_unsetProperties);
      return (Builder) builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Partial)) {
        return false;
      }
      Partial other = (Partial) obj;
      return Objects.equals(name, other.name)
          && Objects.equals(description, other.description)
          && Objects.equals(version, other.version)
          && ignored == other.ignored
          && enabled == other.enabled
          && Objects.equals(_unsetProperties, other._unsetProperties);
    }

    @Override
    public int hashCode() {
      return Objects.hash(name, description, version, ignored, enabled, _unsetProperties);
    }

    @Override
    public String toString() {
      StringBuilder result = new StringBuilder("partial PluginModel{");
      String separator = "";
      if (!_unsetProperties.contains(Property.NAME)) {
        result.append("name=").append(name);
        separator = ", ";
      }
      if (!_unsetProperties.contains(Property.DESCRIPTION)) {
        result.append(separator).append("description=").append(description);
        separator = ", ";
      }
      if (!_unsetProperties.contains(Property.VERSION)) {
        result.append(separator).append("version=").append(version);
        separator = ", ";
      }
      if (!_unsetProperties.contains(Property.IGNORED)) {
        result.append(separator).append("ignored=").append(ignored);
        separator = ", ";
      }
      if (!_unsetProperties.contains(Property.ENABLED)) {
        result.append(separator).append("enabled=").append(enabled);
      }
      return result.append("}").toString();
    }
  }
}
