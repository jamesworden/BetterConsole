// Autogenerated code. Do not modify.
package com.jamesworden.betterconsole.models;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import java.net.InetSocketAddress;
import java.util.EnumSet;
import java.util.Objects;
import java.util.UUID;
import java.util.function.UnaryOperator;
import javax.annotation.Generated;

/**
 * Auto-generated superclass of {@link PlayerModel.Builder}, derived from the API of {@link
 * PlayerModel}.
 */
@Generated("org.inferred.freebuilder.processor.Processor")
abstract class PlayerModel_Builder {

  /**
   * Creates a new builder using {@code value} as a template.
   *
   * <p>If {@code value} is a partial, the builder will return more partials.
   */
  public static PlayerModel.Builder from(PlayerModel value) {
    if (value instanceof Rebuildable) {
      return ((Rebuildable) value).toBuilder();
    } else {
      return new PlayerModel.Builder().mergeFrom(value);
    }
  }

  private enum Property {
    NAME("name"),
    UNIQUE_ID("uniqueId"),
    ADDRESS("address"),
    GAME_MODE("gameMode"),
    OP("op"),
    ;

    private final String name;

    private Property(String name) {
      this.name = name;
    }

    @Override
    public String toString() {
      return name;
    }
  }

  private String name;
  private UUID uniqueId;
  private InetSocketAddress address;
  private String gameMode;
  private boolean op;
  private final EnumSet<Property> _unsetProperties = EnumSet.allOf(Property.class);

  /**
   * Sets the value to be returned by {@link PlayerModel#getName()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code name} is null
   */
  public PlayerModel.Builder setName(String name) {
    this.name = Objects.requireNonNull(name);
    _unsetProperties.remove(Property.NAME);
    return (PlayerModel.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link PlayerModel#getName()} by applying {@code mapper}
   * to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public PlayerModel.Builder mapName(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return setName(mapper.apply(getName()));
  }

  /**
   * Returns the value that will be returned by {@link PlayerModel#getName()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getName() {
    Preconditions.checkState(!_unsetProperties.contains(Property.NAME), "name not set");
    return name;
  }

  /**
   * Sets the value to be returned by {@link PlayerModel#getUniqueId()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code uniqueId} is null
   */
  public PlayerModel.Builder setUniqueId(UUID uniqueId) {
    this.uniqueId = Objects.requireNonNull(uniqueId);
    _unsetProperties.remove(Property.UNIQUE_ID);
    return (PlayerModel.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link PlayerModel#getUniqueId()} by applying {@code
   * mapper} to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public PlayerModel.Builder mapUniqueId(UnaryOperator<UUID> mapper) {
    Objects.requireNonNull(mapper);
    return setUniqueId(mapper.apply(getUniqueId()));
  }

  /**
   * Returns the value that will be returned by {@link PlayerModel#getUniqueId()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public UUID getUniqueId() {
    Preconditions.checkState(!_unsetProperties.contains(Property.UNIQUE_ID), "uniqueId not set");
    return uniqueId;
  }

  /**
   * Sets the value to be returned by {@link PlayerModel#getAddress()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code address} is null
   */
  public PlayerModel.Builder setAddress(InetSocketAddress address) {
    this.address = Objects.requireNonNull(address);
    _unsetProperties.remove(Property.ADDRESS);
    return (PlayerModel.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link PlayerModel#getAddress()} by applying {@code
   * mapper} to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public PlayerModel.Builder mapAddress(UnaryOperator<InetSocketAddress> mapper) {
    Objects.requireNonNull(mapper);
    return setAddress(mapper.apply(getAddress()));
  }

  /**
   * Returns the value that will be returned by {@link PlayerModel#getAddress()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public InetSocketAddress getAddress() {
    Preconditions.checkState(!_unsetProperties.contains(Property.ADDRESS), "address not set");
    return address;
  }

  /**
   * Sets the value to be returned by {@link PlayerModel#getGameMode()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code gameMode} is null
   */
  public PlayerModel.Builder setGameMode(String gameMode) {
    this.gameMode = Objects.requireNonNull(gameMode);
    _unsetProperties.remove(Property.GAME_MODE);
    return (PlayerModel.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link PlayerModel#getGameMode()} by applying {@code
   * mapper} to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public PlayerModel.Builder mapGameMode(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return setGameMode(mapper.apply(getGameMode()));
  }

  /**
   * Returns the value that will be returned by {@link PlayerModel#getGameMode()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getGameMode() {
    Preconditions.checkState(!_unsetProperties.contains(Property.GAME_MODE), "gameMode not set");
    return gameMode;
  }

  /**
   * Sets the value to be returned by {@link PlayerModel#isOp()}.
   *
   * @return this {@code Builder} object
   */
  public PlayerModel.Builder setOp(boolean op) {
    this.op = op;
    _unsetProperties.remove(Property.OP);
    return (PlayerModel.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link PlayerModel#isOp()} by applying {@code mapper} to
   * it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public PlayerModel.Builder mapOp(UnaryOperator<Boolean> mapper) {
    Objects.requireNonNull(mapper);
    return setOp(mapper.apply(isOp()));
  }

  /**
   * Returns the value that will be returned by {@link PlayerModel#isOp()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public boolean isOp() {
    Preconditions.checkState(!_unsetProperties.contains(Property.OP), "op not set");
    return op;
  }

  /**
   * Copies values from {@code value}.
   *
   * @return this {@code Builder} object
   */
  public PlayerModel.Builder mergeFrom(PlayerModel value) {
    PlayerModel_Builder defaults = new PlayerModel.Builder();
    if (defaults._unsetProperties.contains(Property.NAME)
        || !Objects.equals(value.getName(), defaults.getName())) {
      setName(value.getName());
    }
    if (defaults._unsetProperties.contains(Property.UNIQUE_ID)
        || !Objects.equals(value.getUniqueId(), defaults.getUniqueId())) {
      setUniqueId(value.getUniqueId());
    }
    if (defaults._unsetProperties.contains(Property.ADDRESS)
        || !Objects.equals(value.getAddress(), defaults.getAddress())) {
      setAddress(value.getAddress());
    }
    if (defaults._unsetProperties.contains(Property.GAME_MODE)
        || !Objects.equals(value.getGameMode(), defaults.getGameMode())) {
      setGameMode(value.getGameMode());
    }
    if (defaults._unsetProperties.contains(Property.OP) || value.isOp() != defaults.isOp()) {
      setOp(value.isOp());
    }
    return (PlayerModel.Builder) this;
  }

  /**
   * Copies values from {@code template}, skipping unset properties.
   *
   * @return this {@code Builder} object
   */
  public PlayerModel.Builder mergeFrom(PlayerModel.Builder template) {
    // Upcast to access private fields; otherwise, oddly, we get an access violation.
    PlayerModel_Builder base = template;
    PlayerModel_Builder defaults = new PlayerModel.Builder();
    if (!base._unsetProperties.contains(Property.NAME)
        && (defaults._unsetProperties.contains(Property.NAME)
            || !Objects.equals(template.getName(), defaults.getName()))) {
      setName(template.getName());
    }
    if (!base._unsetProperties.contains(Property.UNIQUE_ID)
        && (defaults._unsetProperties.contains(Property.UNIQUE_ID)
            || !Objects.equals(template.getUniqueId(), defaults.getUniqueId()))) {
      setUniqueId(template.getUniqueId());
    }
    if (!base._unsetProperties.contains(Property.ADDRESS)
        && (defaults._unsetProperties.contains(Property.ADDRESS)
            || !Objects.equals(template.getAddress(), defaults.getAddress()))) {
      setAddress(template.getAddress());
    }
    if (!base._unsetProperties.contains(Property.GAME_MODE)
        && (defaults._unsetProperties.contains(Property.GAME_MODE)
            || !Objects.equals(template.getGameMode(), defaults.getGameMode()))) {
      setGameMode(template.getGameMode());
    }
    if (!base._unsetProperties.contains(Property.OP)
        && (defaults._unsetProperties.contains(Property.OP)
            || template.isOp() != defaults.isOp())) {
      setOp(template.isOp());
    }
    return (PlayerModel.Builder) this;
  }

  /**
   * Resets the state of this builder.
   *
   * @return this {@code Builder} object
   */
  public PlayerModel.Builder clear() {
    PlayerModel_Builder defaults = new PlayerModel.Builder();
    name = defaults.name;
    uniqueId = defaults.uniqueId;
    address = defaults.address;
    gameMode = defaults.gameMode;
    op = defaults.op;
    _unsetProperties.clear();
    _unsetProperties.addAll(defaults._unsetProperties);
    return (PlayerModel.Builder) this;
  }

  /**
   * Returns a newly-created {@link PlayerModel} based on the contents of this {@code Builder}.
   *
   * @throws IllegalStateException if any field has not been set
   */
  public PlayerModel build() {
    Preconditions.checkState(_unsetProperties.isEmpty(), "Not set: %s", _unsetProperties);
    return new Value(this);
  }

  /**
   * Returns a newly-created partial {@link PlayerModel} for use in unit tests. State checking will
   * not be performed. Unset properties will throw an {@link UnsupportedOperationException} when
   * accessed via the partial object.
   *
   * <p>The builder returned by {@link PlayerModel.Builder#from(PlayerModel)} will propagate the
   * partial status of its input, overriding {@link PlayerModel.Builder#build() build()} to return
   * another partial. This allows for robust tests of modify-rebuild code.
   *
   * <p>Partials should only ever be used in tests. They permit writing robust test cases that won't
   * fail if this type gains more application-level constraints (e.g. new required fields) in
   * future. If you require partially complete values in production code, consider using a Builder.
   */
  @VisibleForTesting()
  public PlayerModel buildPartial() {
    return new Partial(this);
  }

  private abstract static class Rebuildable implements PlayerModel {
    public abstract Builder toBuilder();
  }

  private static final class Value extends Rebuildable {
    private final String name;
    private final UUID uniqueId;
    private final InetSocketAddress address;
    private final String gameMode;
    private final boolean op;

    private Value(PlayerModel_Builder builder) {
      this.name = builder.name;
      this.uniqueId = builder.uniqueId;
      this.address = builder.address;
      this.gameMode = builder.gameMode;
      this.op = builder.op;
    }

    @Override
    public String getName() {
      return name;
    }

    @Override
    public UUID getUniqueId() {
      return uniqueId;
    }

    @Override
    public InetSocketAddress getAddress() {
      return address;
    }

    @Override
    public String getGameMode() {
      return gameMode;
    }

    @Override
    public boolean isOp() {
      return op;
    }

    @Override
    public Builder toBuilder() {
      PlayerModel_Builder builder = new Builder();
      builder.name = name;
      builder.uniqueId = uniqueId;
      builder.address = address;
      builder.gameMode = gameMode;
      builder.op = op;
      builder._unsetProperties.clear();
      return (Builder) builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Value)) {
        return false;
      }
      Value other = (Value) obj;
      return Objects.equals(name, other.name)
          && Objects.equals(uniqueId, other.uniqueId)
          && Objects.equals(address, other.address)
          && Objects.equals(gameMode, other.gameMode)
          && op == other.op;
    }

    @Override
    public int hashCode() {
      return Objects.hash(name, uniqueId, address, gameMode, op);
    }

    @Override
    public String toString() {
      return "PlayerModel{name="
          + name
          + ", uniqueId="
          + uniqueId
          + ", address="
          + address
          + ", gameMode="
          + gameMode
          + ", op="
          + op
          + "}";
    }
  }

  private static final class Partial extends Rebuildable {
    private final String name;
    private final UUID uniqueId;
    private final InetSocketAddress address;
    private final String gameMode;
    private final boolean op;
    private final EnumSet<Property> _unsetProperties;

    Partial(PlayerModel_Builder builder) {
      this.name = builder.name;
      this.uniqueId = builder.uniqueId;
      this.address = builder.address;
      this.gameMode = builder.gameMode;
      this.op = builder.op;
      this._unsetProperties = builder._unsetProperties.clone();
    }

    @Override
    public String getName() {
      if (_unsetProperties.contains(Property.NAME)) {
        throw new UnsupportedOperationException("name not set");
      }
      return name;
    }

    @Override
    public UUID getUniqueId() {
      if (_unsetProperties.contains(Property.UNIQUE_ID)) {
        throw new UnsupportedOperationException("uniqueId not set");
      }
      return uniqueId;
    }

    @Override
    public InetSocketAddress getAddress() {
      if (_unsetProperties.contains(Property.ADDRESS)) {
        throw new UnsupportedOperationException("address not set");
      }
      return address;
    }

    @Override
    public String getGameMode() {
      if (_unsetProperties.contains(Property.GAME_MODE)) {
        throw new UnsupportedOperationException("gameMode not set");
      }
      return gameMode;
    }

    @Override
    public boolean isOp() {
      if (_unsetProperties.contains(Property.OP)) {
        throw new UnsupportedOperationException("op not set");
      }
      return op;
    }

    private static class PartialBuilder extends Builder {
      @Override
      public PlayerModel build() {
        return buildPartial();
      }
    }

    @Override
    public Builder toBuilder() {
      PlayerModel_Builder builder = new PartialBuilder();
      builder.name = name;
      builder.uniqueId = uniqueId;
      builder.address = address;
      builder.gameMode = gameMode;
      builder.op = op;
      builder._unsetProperties.clear();
      builder._unsetProperties.addAll(_unsetProperties);
      return (Builder) builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Partial)) {
        return false;
      }
      Partial other = (Partial) obj;
      return Objects.equals(name, other.name)
          && Objects.equals(uniqueId, other.uniqueId)
          && Objects.equals(address, other.address)
          && Objects.equals(gameMode, other.gameMode)
          && op == other.op
          && Objects.equals(_unsetProperties, other._unsetProperties);
    }

    @Override
    public int hashCode() {
      return Objects.hash(name, uniqueId, address, gameMode, op, _unsetProperties);
    }

    @Override
    public String toString() {
      StringBuilder result = new StringBuilder("partial PlayerModel{");
      String separator = "";
      if (!_unsetProperties.contains(Property.NAME)) {
        result.append("name=").append(name);
        separator = ", ";
      }
      if (!_unsetProperties.contains(Property.UNIQUE_ID)) {
        result.append(separator).append("uniqueId=").append(uniqueId);
        separator = ", ";
      }
      if (!_unsetProperties.contains(Property.ADDRESS)) {
        result.append(separator).append("address=").append(address);
        separator = ", ";
      }
      if (!_unsetProperties.contains(Property.GAME_MODE)) {
        result.append(separator).append("gameMode=").append(gameMode);
        separator = ", ";
      }
      if (!_unsetProperties.contains(Property.OP)) {
        result.append(separator).append("op=").append(op);
      }
      return result.append("}").toString();
    }
  }
}
